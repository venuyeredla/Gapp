package main

import "text/template"

var bptreeTmpl = template.Must(template.New("tmpl").Parse(
	`package {{.packageName}}

/*
* This file is machine generated by fs2-generic. You can obtain
* fs2-generic from github.com/timtadh/fs2/fs2-generic . To install
*
*   $ go get github.com/timtadh/fs2
*   $ go install github.com/timtadh/fs2/fs2-generic
*
* The command used to generate the file was
*
*   $ {{.argv}}
*
* By including this code (and linking to github.com/timtadh/fs2) you
* accept the terms of the GPL version 3 unless another license has been
* obtained in writing from the author(s) of the package. The list of
* authors and full licensing information is located at
* https://github.com/timtadh/fs2/LICENSE
*
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 3 of the License, or (at
* your option) any later version.
*
* This library is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this library; if not, write to the Free Software
* Foundation, Inc.,
*   51 Franklin Street, Fifth Floor,
*   Boston, MA  02110-1301
*   USA
*/

import (
	"sync"
)

import (
	"github.com/timtadh/fs2"
	"github.com/timtadh/fs2/bptree"
	"github.com/timtadh/fs2/fmap"
){{if .imports}}

import ({{range $imp := .imports}}
	"{{$imp}}"{{end}}
){{end}}


type MultiMap interface {
	Keys() (KeyIterator, error)
	Values() (ValueIterator, error)
	Iterate() (Iterator, error)
	Backward() (Iterator, error)
	Find(key {{.keyType}}) (Iterator, error)
	DoFind(key {{.keyType}}, do func({{.keyType}}, {{.valueType}}) error) error
	Range(from, to {{.keyType}}) (Iterator, error)
	DoRange(from, to {{.keyType}}, do func({{.keyType}}, {{.valueType}}) error) error
	Has(key {{.keyType}}) (bool, error)
	Count(key {{.keyType}}) (int, error)
	Add(key {{.keyType}}, value {{.valueType}}) error
	Remove(key {{.keyType}}, where func({{.valueType}}) bool) error
	Size() int
	Close() error
	Delete() error
}

type Iterator func() ({{.keyType}}, {{.valueType}}, error, Iterator)
type KeyIterator func() ({{.keyType}}, error, KeyIterator)
type ValueIterator func() ({{.valueType}}, error, ValueIterator)

func Do(run func() (Iterator, error), do func(key {{.keyType}}, value {{.valueType}}) error) error {
	kvi, err := run()
	if err != nil {
		return err
	}
	var key {{.keyType}}
	var value {{.valueType}}
	for key, value, err, kvi = kvi(); kvi != nil; key, value, err, kvi = kvi() {
		e := do(key, value)
		if e != nil {
			return e
		}
	}
	return err
}

func DoKey(run func() (KeyIterator, error), do func({{.keyType}}) error) error {
	it, err := run()
	if err != nil {
		return err
	}
	var item {{.keyType}}
	for item, err, it = it(); it != nil; item, err, it = it() {
		e := do(item)
		if e != nil {
			return e
		}
	}
	return err
}

func DoValue(run func() (ValueIterator, error), do func({{.valueType}}) error) error {
	it, err := run()
	if err != nil {
		return err
	}
	var item {{.valueType}}
	for item, err, it = it(); it != nil; item, err, it = it() {
		e := do(item)
		if e != nil {
			return e
		}
	}
	return err
}

type BpTree struct {
	bf *fmap.BlockFile
	bpt *bptree.BpTree
	mutex sync.Mutex{{if .useParameters}}
	serializeKey func({{.keyType}}) []byte
	serializeValue func({{.valueType}}) []byte
	deserializeKey func([]byte) {{.keyType}}
	deserializeValue func([]byte) {{.valueType}}{{end}}
}

{{if .useParameters}}func AnonBpTree(
	serializeKey func({{.keyType}}) []byte,
	serializeValue func({{.valueType}}) []byte,
	deserializeKey func([]byte) {{.keyType}},
	deserializeValue func([]byte) {{.valueType}},
) (*BpTree, error) { {{else}}func AnonBpTree() (*BpTree, error) { {{end}}
	bf, err := fmap.Anonymous(fmap.BLOCKSIZE)
	if err != nil {
		return nil, err
	}
	{{if .useParameters}}return newBpTree(bf, serializeKey, serializeValue, deserializeKey, deserializeValue){{else}}return newBpTree(bf){{end}}
}

{{if .useParameters}}func NewBpTree(
	path string,
	serializeKey func({{.keyType}}) []byte,
	serializeValue func({{.valueType}}) []byte,
	deserializeKey func([]byte) {{.keyType}},
	deserializeValue func([]byte) {{.valueType}},
) (*BpTree, error) { {{else}}func NewBpTree(path string) (*BpTree, error) { {{end}}
	bf, err := fmap.CreateBlockFile(path)
	if err != nil {
		return nil, err
	}
	{{if .useParameters}}return newBpTree(bf, serializeKey, serializeValue, deserializeKey, deserializeValue){{else}}return newBpTree(bf){{end}}
}

{{if .useParameters}}func OpenBpTree(
	path string,
	serializeKey func({{.keyType}}) []byte,
	serializeValue func({{.valueType}}) []byte,
	deserializeKey func([]byte) {{.keyType}},
	deserializeValue func([]byte) {{.valueType}},
) (*BpTree, error) { {{else}}func OpenBpTree(path string) (*BpTree, error) { {{end}}
	bf, err := fmap.OpenBlockFile(path)
	if err != nil {
		return nil, err
	}
	bpt, err := bptree.Open(bf)
	if err != nil {
		return nil, err
	}
	b := &BpTree{
		bf: bf,
		bpt: bpt,{{if .useParameters}}
		serializeKey: serializeKey,
		serializeValue: serializeValue,
		deserializeKey: deserializeKey,
		deserializeValue: deserializeValue,{{end}}
	}
	return b, nil
}

{{if .useParameters}}func newBpTree(
	bf *fmap.BlockFile,
	serializeKey func({{.keyType}}) []byte,
	serializeValue func({{.valueType}}) []byte,
	deserializeKey func([]byte) {{.keyType}},
	deserializeValue func([]byte) {{.valueType}},
) (*BpTree, error) { {{else}}func newBpTree(bf *fmap.BlockFile) (*BpTree, error) { {{end}}
	bpt, err := bptree.New(bf, {{.keySize}}, {{.valueSize}})
	if err != nil {
		return nil, err
	}
	b := &BpTree{
		bf: bf,
		bpt: bpt,{{if .useParameters}}
		serializeKey: serializeKey,
		serializeValue: serializeValue,
		deserializeKey: deserializeKey,
		deserializeValue: deserializeValue,{{end}}
	}
	return b, nil
}

func (b *BpTree) Close() error {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bf.Close()
}

func (b *BpTree) Delete() error {
	err := b.Close()
	if err != nil {
		return err
	}
	if b.bf.Path() != "" {
		return b.bf.Remove()
	}
	return nil
}

func (b *BpTree) Size() int {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Size()
}

func (b *BpTree) Add(key {{.keyType}}, val {{.valueType}}) error {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Add({{.serializeKey}}(key), {{.serializeValue}}(val))
}

func (b *BpTree) Count(key {{.keyType}}) (int, error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Count({{.serializeKey}}(key))
}

func (b *BpTree) Has(key {{.keyType}}) (bool, error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Has({{.serializeKey}}(key))
}

func (b *BpTree) kvIter(kvi fs2.Iterator) (it Iterator) {
	it = func() (key {{.keyType}}, value {{.valueType}}, err error, _ Iterator) {
		b.mutex.Lock()
		defer b.mutex.Unlock()
		var k, v []byte
		k, v, err, kvi = kvi()
		if err != nil {
			return {{.keyEmpty}}, {{.valueEmpty}}, err, nil
		}
		if kvi == nil {
			return {{.keyEmpty}}, {{.valueEmpty}}, nil, nil
		}
		key = {{.deserializeKey}}(k)
		value = {{.deserializeValue}}(v)
		return key, value, nil, it
	}
	return it
}

func (b *BpTree) keyIter(raw fs2.ItemIterator) (it KeyIterator) {
	it = func() (key {{.keyType}}, err error, _ KeyIterator) {
		b.mutex.Lock()
		defer b.mutex.Unlock()
		var i []byte
		i, err, raw = raw()
		if err != nil {
			return {{.keyEmpty}}, err, nil
		}
		if raw == nil {
			return {{.keyEmpty}}, nil, nil
		}
		key = {{.deserializeKey}}(i)
		return key, nil, it
	}
	return it
}

func (b *BpTree) valueIter(raw fs2.ItemIterator) (it ValueIterator) {
	it = func() (value {{.valueType}}, err error, _ ValueIterator) {
		b.mutex.Lock()
		defer b.mutex.Unlock()
		var i []byte
		i, err, raw = raw()
		if err != nil {
			return {{.valueEmpty}}, err, nil
		}
		if raw == nil {
			return {{.valueEmpty}}, nil, nil
		}
		value = {{.deserializeValue}}(i)
		return value, nil, it
	}
	return it
}

func (b *BpTree) Keys() (it KeyIterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Keys()
	if err != nil {
		return nil, err
	}
	return b.keyIter(raw), nil
}

func (b *BpTree) Values() (it ValueIterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Values()
	if err != nil {
		return nil, err
	}
	return b.valueIter(raw), nil
}

func (b *BpTree) Find(key {{.keyType}}) (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Find({{.serializeKey}}(key))
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) DoFind(key {{.keyType}}, do func({{.keyType}}, {{.valueType}}) error) error {
	return Do(func()(Iterator, error) { return b.Find(key) }, do)
}

func (b *BpTree) Iterate() (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Iterate()
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) Range(from, to {{.keyType}}) (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Range({{.serializeKey}}(from), {{.serializeKey}}(to))
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) DoRange(from, to {{.keyType}}, do func({{.keyType}}, {{.valueType}}) error) error {
	return Do(func()(Iterator, error) { return b.Range(from, to) }, do)
}

func (b *BpTree) Backward() (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Backward()
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) Remove(key {{.keyType}}, where func({{.valueType}}) bool) error {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Remove({{.serializeKey}}(key), func(bytes []byte) bool {
		return where({{.deserializeValue}}(bytes))
	})
}

`))
